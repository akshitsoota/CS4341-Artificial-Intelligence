Group members: Ankit Kumar, Akshit Soota, Dan Alfred
Team Name:

How to compile:
To compile our program, first navigate into src/student/cs4341/project2. Then, run the following command:
javac evaluation/*.java fileinterface/*.java game/*.java *.java

The compiled .class files should now be present in their respective directories.
Additionally, our program was compiled and tested with Java 8, but should also compile on Java 7.

How to run:
To run our program, navigate to src/ and run the following command:
java student.cs4341.project2.Main

The program will print out "Initialized game for -----" to indicate that it is ready.

Utility function:
Our program utilizes a simple utility function to indicate wins or losses when evaluating. We assigned a value of
+1000 for wins, and -1000 for losses. Both of these values were selected because they are higher than any
value the evaluation function could return, indicating a terminal state with certainty.

Evaluation function:
To evaluate non-terminal states of the board, we have implemented an algorithm that considers the state of each
player in the game. Our evaluation function loops through the board and counts, for the given move, how many
N in-a-row it and the enemy have. We factor in 4 and 3 in-a-row, and assign coefficients for each. The enemy's
coefficients are negative to indicate that an improvement in this state is worse for the player. However, the
magnitude of our coefficients lead the AI to play offensively, valuing 4 in-a-rows of our own before blocking
potential enemy 3 in-a-rows from becoming 4 in-a-rows. 

Expansion heuristics:
We implemented heuristics to keep the minimax algorithm from expanding every possible state. Our heuristics
only allow for expansion of game states where the planned move is adjacent to an existing move. This is because
a move anywhere else on the board would have no immediate impact on the game, and because the opponent would
not likely pick a move that is not adjacent to the current playing area.

Time-limit strategy:
To ensure the time limit is met, we utilized a separate thread to conduct computations on the possible game states
while maintaining a global variable with the best move so far. Once the thread timer has reached 8 seconds (2
seconds allowed as buffer for finalizing computations and writing to file), we take the best possible move and
submit it to the referee.

Results:
To test our program, we launched two instances with different group names and had them play against each other.
We observed our AI blocking enemy 3 in-a-rows and attempting to create its own. Additionally, we used a modified
referee which printed to board to confirm what moves were being made, and compared the moves made by each other
to the moves that we would have made ourselves.