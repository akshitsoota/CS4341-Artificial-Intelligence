Group members: Ankit Kumar, Akshit Soota, Dan Alfred

How to compile:
To compile our program, first navigate into src/student/cs4341/project2. Then, run the following command:
javac evaluation/*.java fileinterface/*.java game/*.java *.java

The compiled .class files should now be present in their respective directories.
Additionally, our program was compiled and tested with Java 8, but should also compile on Java 7.

How to run:
To run our program, navigate to src/ and run the following command:
java student.cs4341.project2.Main

The program will print out "Initialized game for -----" to indicate that it is ready.

Utility function:
Our program utilizes a simple utility function to indicate wins or losses when evaluating. We assigned a value of
+1000 for wins, and -1000 for losses. Both of these values were selected because they are higher than any
value the evaluation function could return, indicating a terminal state with certainty.

Evaluation function:


Expansion heuristics:
We implemented heuristics to keep the minimax algorithm from expanding every possible state. Our heuristics
only allow for expansion of game states where the planned move is adjacent to an existing move. This is because
a move anywhere else on the board would have no immediate impact on the game, and because the opponent would
not likely pick a move that is not adjacent to the current playing area.

Time-limit strategy:
To ensure the time limit is met, we utilized a separate thread to conduct computations on the possible game states
while maintaining a global variable with the best move so far. Once the thread timer has reached 8 seconds (2
seconds allowed as buffer for finalizing computations and writing to file), we take the best possible move and
submit it to the referee.

Results:
To test our program, we launched two instances with different group names and had them play against each other.